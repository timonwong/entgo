{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{ define "entql" }}

{{ $pkg := base $.Config.Package }}
{{ template "header" $ }}

import (
	{{- range $n := $.Nodes }}
		"{{ $.Config.Package }}/{{ $n.Package }}"
	{{- end }}

	"github.com/facebook/ent/dialect/sql"
	"github.com/facebook/ent/dialect/sql/sqlgraph"
	"github.com/facebook/ent/entql"
	"github.com/facebook/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 0, {{ len $.Nodes }})}
	{{- range $n := $.Nodes }}
		graph.Nodes = append(graph.Nodes, &sqlgraph.Node{
			NodeSpec: sqlgraph.NodeSpec{
				Table: {{ $n.Package }}.Table,
				Columns: {{ $n.Package }}.Columns,
				ID: &sqlgraph.FieldSpec{
					Type: field.{{ $n.ID.Type.ConstName }},
					Column: {{ $n.Package }}.{{ $n.ID.Constant }},
				},
			},
			Type: "{{ $n.Name }}",
			Fields: map[string]*sqlgraph.FieldSpec{
				{{- range $f := $n.Fields }}
                    {{ $n.Package }}.{{ $f.Constant }}: {Type: field.{{ $f.Type.ConstName }}, Column: {{ $n.Package }}.{{ $f.Constant }}},
				{{- end }}
			},
		})
	{{- end }}
	{{- range $n := $.Nodes }}
		{{- range $e := $n.Edges }}
			graph.MustAddE(
				"{{ $e.Name }}",
				&sqlgraph.EdgeSpec{
					Rel: sqlgraph.{{ $e.Rel.Type }},
					Inverse: {{ $e.IsInverse }},
					Table: {{ $n.Package }}.{{ $e.TableConstant }},
					Columns: {{ if $e.M2M }}{{ $n.Package }}.{{ $e.PKConstant }}{{ else }}[]string{ {{ $n.Package }}.{{ $e.ColumnConstant }} }{{ end }},
					Bidi: {{ $e.Bidi }},
				},
				"{{ $n.Name }}",
				"{{ $e.Type.Name }}",
			)
		{{- end }}
	{{- end }}
	return graph
}()

{{- range $i, $n := $.Nodes }}
    {{ $builder := $n.QueryName }}
    {{ $receiver := receiver $builder }}
	{{ $filter :=  print $n.Name "Filter" }}

	// EntQL returns an entql.Where implementation to apply filters on the {{ $builder }} builder.
	func ({{ $receiver }} *{{ $builder }}) EntQL() *{{ $filter }} {
		return &{{ $filter }}{ {{ $receiver }} }
	}

	// {{ $filter }} provides a generic filtering capability at runtime for {{ $builder }}.
	type {{ $filter }} struct {
		*{{ $builder }}
	}

	// Where applies the entql predicate on the query filter.
	func (f *{{ $filter }}) Where(p entql.P) {
		f.predicates = append(f.predicates, predicate.{{ $n.Name }}(func(s *sql.Selector) {
			if err := schemaGraph.EvalP(schemaGraph.Nodes[{{ $i }}].Type, p, s); err != nil {
				s.AddError(err)
			}
		}))
	}

	{{ range $f := $n.Fields }}
		{{ $type := $f.Type.Type.String }}
		{{ $iface := print (pascal $type) "P" }}
		{{ if $f.IsTime }}{{ $iface = "TimeP" }}{{ else if $f.IsBytes }}{{ $iface = "BytesP" }}{{ end }}
		// Where{{ $f.StructField }} applies the entql {{ $type }} predicate on the {{ $f.Name }} field.
		func (f *{{ $filter }}) Where{{ $f.StructField }}(p entql.{{ $iface }}) {
			f.Where(p.Field({{ $n.Package }}.{{ $f.Constant }}))
		}
	{{ end }}

    {{ range $e := $n.Edges }}
        {{ $func := print "WhereHas" $e.StructField }}
		// {{ $func }} applies a predicate to check if query has an edge {{ $e.Name }}.
		func (f *{{ $filter }}) {{ $func }}() {
			f.Where(entql.HasEdge("{{ $e.Name }}"))
		}

		{{ $func = print "WhereHas" $e.StructField "With" }}
		// {{ $func }} applies a predicate to check if query has an edge {{ $e.Name }} with a given conditions (other predicates).
		func (f *{{ $filter }}) {{ $func }}(p ...entql.P) {
			f.Where(entql.HasEdgeWith("{{ $e.Name }}", p...))
		}
    {{ end }}
{{- end }}

{{ end }}
